/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/octree/camera.js":
/*!******************************!*\
  !*** ./src/octree/camera.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"move\": () => (/* binding */ move),\n/* harmony export */   \"moveChoice\": () => (/* binding */ moveChoice),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"setChoice\": () => (/* binding */ setChoice),\n/* harmony export */   \"setOrbit\": () => (/* binding */ setOrbit),\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n/* global vec, add, mul, sub */\n\nlet current = {};\nlet currentChoice = -1;\nlet target = {};\nlet targetChoice = -1;\nlet start = 0;\nlet dur = 0;\nlet orbit = null;\n\nfunction setOrbit(_orbit) {\n  orbit = _orbit;\n}\n\nfunction set(pos, lookAt, zoom) {\n  current = { pos, lookAt, zoom };\n  currentChoice = -1;\n  target = null;\n}\n\nfunction setChoice(choice) {\n  currentChoice = choice;\n  targetChoice = -1;\n}\n\nfunction move(pos, lookAt, zoom, _dur) {\n  target = { pos, lookAt, zoom };\n  start = Date.now();\n  dur = _dur;\n}\n\nfunction moveChoice(choice, _dur) {\n  targetChoice = choice;\n  start = Date.now();\n  dur = _dur;\n}\n\nfunction update() {\n  if (currentChoice === -1) {\n    if (target) {\n      const t = (Date.now() - start) / 1000 / dur;\n      const clampT = Math.min(t, 1);\n      const now = lerp(current, target, clampT);\n      if (t >= 1) {\n        current = target;\n        target = null;\n      }\n      return now;\n    } else {\n      return current;\n    }\n  } else {\n    if (targetChoice > -1) {\n      const t = (Date.now() - start) / 1000 / dur;\n      const clampT = Math.min(t, 1);\n      const now = lerp(camChoice(currentChoice), camChoice(targetChoice), clampT);\n      if (t >= 1) {\n        currentChoice = targetChoice;\n        targetChoice = -1;\n      }\n      return now;\n    } else {\n      return camChoice(currentChoice);\n    }\n  }\n}\n\nfunction lerp(from, to, t) {\n  return {\n    pos: add(from.pos, mul(sub(to.pos, from.pos), t)),\n    lookAt: add(from.lookAt, mul(sub(to.lookAt, from.lookAt), t)),\n    zoom: from.zoom + (to.zoom - from.zoom) * t,\n  };\n}\n\n// pos: vec(0, 0.25, -2);\nwindow.locX = 0;\nwindow.locY = 0.25;\nwindow.locZ = -2;\n\nfunction pick(choice) {\n  const t = Date.now() / 1000;\n\n  if (choice === 0) {\n    // sweeping in/out is default (0)\n    const angle = Math.sin(t);\n    const angleY = Math.cos(t) / 2;\n    return {\n      pos: vec(Math.sin(angle) + Math.cos(angleY), Math.sin(angleY) / 2 + 0.2, -Math.cos(angle)),\n      lookAt: vec(0, 0, 0),\n      zoom: 0.5 + (Math.sin(t + 0.5) + 1) / 4,\n    };\n  } else if (choice === 1) {\n    // rotate from slightly above\n    const angle = t / 1.4;\n    return {\n      pos: vec(Math.sin(angle), 0.3, -Math.cos(angle)),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 1,\n    };\n  } else if (choice === 2) {\n    // steady from the right\n    const angle = -1;\n    return {\n      pos: vec(Math.sin(angle), 0.3, -Math.cos(angle)),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 1,\n    };\n  } else if (choice === 3) {\n    // steady front\n    return {\n      pos: vec(0, 0.2, -1),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 1.3,\n    };\n  } else if (choice === 4) {\n    // front telephoto, full body\n    return {\n      pos: vec(0, 0.25, -2),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 6,\n    };\n  } else if (choice === 5) {\n    // front telephoto, bust\n    return {\n      pos: vec(0, 0.25, -2),\n      lookAt: vec(-0.05, 2.0, -0.4),\n      zoom: 9,\n    };\n  } else if (choice === 6) {\n    // full body, steady profile right\n    const angle = -1.6;\n    return {\n      pos: vec(Math.sin(angle), 0.2, -Math.cos(angle)),\n      lookAt: vec(0, 0.5, 0),\n      zoom: 2,\n    };\n  } else if (choice === 7) {\n    // rotating under the chin\n    const angle = t / 1.2;\n    return {\n      pos: vec(Math.sin(angle), 0.2, -Math.cos(angle)),\n      lookAt: vec(-0.05, 2.0, -0.4),\n      zoom: 2,\n    };\n  } else if (choice === 8) {\n    // iso view (iso-ish) BAYC style\n    return {\n      pos: vec(-1.2, 0.35, -1.75),\n      lookAt: vec(-0.05, 2.0, -0.4),\n      zoom: 8,\n    };\n  } else if (choice === 9) {\n    // iso view (iso-ish) full body\n    return {\n      pos: vec(-1.2, 0.35, -1.75),\n      lookAt: vec(-0.05, 1.25, -0.4),\n      zoom: 7,\n    };\n  } else if (choice === 10) {\n    // profile style (azuki ish)\n    // const angle = -1.6;\n    return {\n      pos: vec(-1, 0.25, -0.2),\n      lookAt: vec(0, 1.7, -0.2),\n      zoom: 4.5,\n    };\n  } else if (choice === 11) {\n    // slow back and forth\n    const angle = t / 6;\n    const x = Math.sin(angle) / 2;\n    return {\n      pos: vec(x, 0.25, -2),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 6,\n    };\n  } else if (choice === 13) {\n    // explicit location\n    // console.log('location', window.locX, window.locY, window.locZ);\n    return {\n      pos: vec(window.locX, 0.2, -1),\n      lookAt: vec(-0.05, 1.5, -0.4),\n      zoom: 1.3,\n    };\n  } else {\n    // camera 12\n    // orbit with manual control\n    return { ...orbit, zoom: 5, skipScale: true };\n  }\n}\n\nfunction camChoice(choice) {\n  const posScale = 20;\n  const zoomScale = 3;\n\n  const cam = pick(choice);\n  if (cam.skipScale) {\n    cam.zoom *= zoomScale;\n    return cam;\n  } else {\n    return {\n      pos: mul(cam.pos, posScale),\n      lookAt: cam.lookAt,\n      zoom: cam.zoom * zoomScale,\n    };\n  }\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/camera.js?");

/***/ }),

/***/ "./src/octree/gl.js":
/*!**************************!*\
  !*** ./src/octree/gl.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"copyArrayToTexture\": () => (/* binding */ copyArrayToTexture),\n/* harmony export */   \"copyBufferToTexture\": () => (/* binding */ copyBufferToTexture),\n/* harmony export */   \"createProgram\": () => (/* binding */ createProgram),\n/* harmony export */   \"drawFullscreenTriangle\": () => (/* binding */ drawFullscreenTriangle),\n/* harmony export */   \"fence\": () => (/* binding */ fence),\n/* harmony export */   \"makeBuffer\": () => (/* binding */ makeBuffer),\n/* harmony export */   \"readBuffer\": () => (/* binding */ readBuffer),\n/* harmony export */   \"setUniforms\": () => (/* binding */ setUniforms),\n/* harmony export */   \"setupFullscreenTriangle\": () => (/* binding */ setupFullscreenTriangle),\n/* harmony export */   \"setupIndexVao\": () => (/* binding */ setupIndexVao),\n/* harmony export */   \"setupUbo\": () => (/* binding */ setupUbo),\n/* harmony export */   \"textureFromPixelArray\": () => (/* binding */ textureFromPixelArray)\n/* harmony export */ });\nfunction textureFromPixelArray(gl, dataArray, width, height) {\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, dataArray);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  return texture;\n}\n\nfunction copyArrayToTexture(gl, array, texture, size) {\n  const height = size ? Math.ceil(size / 2048) : 2048;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 2048, height, gl.RGBA, gl.FLOAT, array);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n}\n\nfunction copyBufferToTexture(gl, buffer, texture, offset, size) {\n  const height = size ? Math.ceil(size / 2048) : 2048;\n  gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 2048, height, gl.RGBA, gl.FLOAT, offset);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);\n}\n\nfunction checkShaderError(gl, shader) {\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.log('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n  }\n}\n\nfunction checkLinkError(gl, program) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    throw new Error(gl.getProgramInfoLog(program));\n  }\n}\n\nfunction createProgram(gl, vertex, fragment, beforeLinkFn) {\n  const program = gl.createProgram();\n\n  const vs = gl.createShader(gl.VERTEX_SHADER /*35633*/);\n  gl.shaderSource(vs, vertex);\n  gl.compileShader(vs);\n  checkShaderError(gl, vs);\n  gl.attachShader(program, vs);\n\n  const fs = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fs, fragment);\n  gl.compileShader(fs);\n  checkShaderError(gl, fs);\n  gl.attachShader(program, fs);\n\n  // const fsrc = gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(fs);\n  // console.log(fsrc);\n\n  if (beforeLinkFn) {\n    beforeLinkFn(program);\n  }\n\n  gl.linkProgram(program);\n  checkLinkError(gl, program);\n  return program;\n}\n\nfunction setUniforms(gl, program, uniforms) {\n  uniforms.forEach(([name, type, value]) => {\n    // if (show) {\n    //   console.log({ name, type, value });\n    // }\n    gl[`uniform${type}`](gl.getUniformLocation(program, name), value);\n  });\n}\n\nfunction setupFullscreenTriangle(gl) {\n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n  gl.enableVertexAttribArray(0);\n  gl.vertexAttribPointer(0, 2, 5120, 0, 0, 0);\n  gl.bufferData(gl.ARRAY_BUFFER, new Int8Array([-3, 1, 1, -3, 1, 1]), 35044);\n}\n\nfunction drawFullscreenTriangle(gl) {\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n  gl.drawArrays(6, 0, 3);\n}\n\nfunction makeBuffer(gl, size, data) {\n  const buf = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n  gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW);\n  if (data) {\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, Float32Array.from(data));\n  }\n  return buf;\n}\n\nfunction setupIndexVao(gl, program, buffer, attributeName) {\n  const loc = gl.getAttribLocation(program, attributeName);\n\n  const vao = gl.createVertexArray();\n  gl.bindVertexArray(vao);\n\n  // const buffer = makeBufferAndSetAttribute(gl, nodeIndexData, nodeIndexLoc);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n  gl.enableVertexAttribArray(loc);\n  gl.vertexAttribPointer(\n    loc,\n    1, // size (num components)\n    gl.FLOAT, // type of data in buffer\n    false, // normalize\n    0, // stride (0 = auto)\n    0, // offset\n  );\n\n  return vao;\n}\n\nfunction readBuffer(gl, buffer, results, offset = 0, size = 0) {\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.getBufferSubData(\n    gl.ARRAY_BUFFER,\n    offset, // byte offset into GPU buffer,\n    results,\n    0,\n    size,\n  );\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  return results;\n}\n\nasync function fence(gl) {\n  return new Promise(function (resolve) {\n    var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush(); // Ensure the fence is submitted.\n    function check() {\n      var status = gl.getSyncParameter(sync, gl.SYNC_STATUS);\n      if (status == gl.SIGNALED) {\n        gl.deleteSync(sync);\n        resolve();\n      } else {\n        setTimeout(check, 0);\n      }\n    }\n    setTimeout(check, 0);\n  });\n}\n\nfunction setupUbo(gl, program, paramName, varName, data) {\n  // ==== START OF PART A ====\n\n  // Get the index of the Uniform Block from any program\n  const blockIndex = gl.getUniformBlockIndex(program, paramName);\n\n  // Get the size of the Uniform Block in bytes\n  const blockSize = gl.getActiveUniformBlockParameter(\n    program,\n    blockIndex,\n    gl.UNIFORM_BLOCK_DATA_SIZE,\n  );\n\n  // Create Uniform Buffer to store our data\n  const uboBuffer = gl.createBuffer();\n\n  // Bind it to tell WebGL we are working on this buffer\n  gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);\n\n  // Allocate memory for our buffer equal to the size of our Uniform Block\n  // We use dynamic draw because we expect to respecify the contents of the buffer frequently\n  gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);\n\n  // Unbind buffer when we're done using it for now\n  // Good practice to avoid unintentionally working on it\n  gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n\n  // Bind the buffer to a binding point\n  // Think of it as storing the buffer into a special UBO ArrayList\n  // The second argument is the index you want to store your Uniform Buffer in\n  // Let's say you have 2 unique UBO, you'll store the first one in index 0 and the second one in index 1\n  gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);\n\n  // Name of the member variables inside of our Uniform Block\n  const uboVariableNames = [varName];\n\n  // Get the respective index of the member variables inside our Uniform Block\n  const uboVariableIndices = gl.getUniformIndices(program, uboVariableNames);\n\n  // Get the offset of the member variables inside our Uniform Block in bytes\n  const uboVariableOffsets = gl.getActiveUniforms(program, uboVariableIndices, gl.UNIFORM_OFFSET);\n\n  // Create an object to map each variable name to its respective index and offset\n  const uboVariableInfo = {};\n\n  uboVariableNames.forEach((name, index) => {\n    uboVariableInfo[name] = {\n      index: uboVariableIndices[index],\n      offset: uboVariableOffsets[index],\n    };\n  });\n\n  // ==== END OF PART A ====\n\n  // ==== START OF PART B ====\n\n  let index;\n\n  // The 3rd argument is the binding point of our Uniform Buffer\n  // uniformBlockBinding tells WebGL to\n  // link the Uniform Block inside of this program\n  // to the Uniform Buffer at index X of our Special UBO ArrayList\n  //\n  // Remember that we placed our UBO at index 0 of our Special UBO ArrayList in line 213 in Part A\n\n  index = gl.getUniformBlockIndex(program, paramName);\n  gl.uniformBlockBinding(program, index, 0);\n\n  // ==== END OF PART B ====\n\n  // ==== START OF PART C ====\n\n  gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);\n\n  // Push some data to our Uniform Buffer\n\n  gl.bufferSubData(gl.UNIFORM_BUFFER, uboVariableInfo[varName].offset, data, 0);\n\n  gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n\n  // ==== END OF PART C ====\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/gl.js?");

/***/ }),

/***/ "./src/octree/oct.js":
/*!***************************!*\
  !*** ./src/octree/oct.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _raymarch_octree_build_raymarch_octree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raymarch-octree/build-raymarch-octree.js */ \"./src/octree/raymarch-octree/build-raymarch-octree.js\");\n/* harmony import */ var _theming__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../theming */ \"./src/theming.js\");\n/* global vec */\n\n\n\n\nconst getQueryVariable = (variable) => {\n  let query = w.location.search.substring(1);\n  let vars = query.split('&');\n  for (let i = 0; i < vars.length; i++) {\n    let pair = vars[i].split('=');\n    if (decodeURIComponent(pair[0]) == variable) {\n      return decodeURIComponent(pair[1]);\n    }\n  }\n};\n\nlet w = window;\n\nlet current = null;\nlet next = null;\nlet state = null;\nlet isBuilding = false;\nlet saveFrame = false;\n\nlet downloadCallback = false;\nlet downloadNumber = 'notdefined';\n\nconst renderSelected = async () => {\n  isBuilding = true;\n\n  if (next) {\n    cleanUpCurrent();\n    await waitAFrame();\n    current = next;\n    next = null;\n    await waitAFrame();\n  }\n\n  const { camera, voxelSize, hash, modelDepth } = current;\n  const bounds = {\n    min: vec(-3.51, -1.1, -3.51),\n    max: vec(3.51, 8, 3.51),\n  };\n  state = await _raymarch_octree_build_raymarch_octree_js__WEBPACK_IMPORTED_MODULE_0__.build(hash, camera, voxelSize, bounds, afterRender, modelDepth);\n\n  isBuilding = false;\n};\nwindow.renderSelected = renderSelected;\n\nconst passImageUp = (data) => {\n  const message = {\n    name: 'v-image',\n    image: data,\n  };\n  parent.postMessage(message, '*');\n};\n\n// const downloadImageAs = (data) => {\n//   let { imageData, imageName } = data;\n//   var link = document.createElement('a');\n//   link.download = imageName;\n//   link.href = imageData;\n//   document.body.appendChild(link);\n//   link.click();\n//   document.body.removeChild(link);\n// };\n\n// const makeRandomHash = () => {\n//   const hashInput = Date.now();\n//   const desiredHashArray = [];\n//   const hashAsNumber = parseInt(hashInput, 16);\n\n//   for (const name in w.repo.models) {\n//     const models = w.repo.models[name].filter((m) => !!m);\n//     const modulo = hashAsNumber % models.length;\n//     const sel = models[modulo];\n//     desiredHashArray.push(`${name}:the:${sel.the.index}`);\n//   }\n\n//   return desiredHashArray.join('-');\n// };\n\n// const setFirstModel = () => {\n//   const desiredHashArray = [];\n\n//   for (const name in w.repo.models) {\n//     const models = w.repo.models[name].filter((m) => !!m);\n//     const sel = models[0];\n//     desiredHashArray.push(`${name}:the:${sel.the.index}`);\n//   }\n\n//   return desiredHashArray.join('-');\n// };\n\nconst cleanUpCurrent = () => {\n  state.stop();\n\n  let canvases = document.querySelectorAll('canvas');\n  // console.log('w.addEventListener ~ canvases', canvases.length);\n  canvases.forEach((e) => e.remove());\n  canvases = null;\n\n  state = null;\n};\n\nasync function waitAFrame() {\n  return new Promise((r) => setTimeout(r, 0));\n}\n\nfunction afterRender(gl) {\n  if (next && !isBuilding) {\n    renderSelected();\n  } else if (saveFrame) {\n    saveFrame = false;\n    const downloadPrefix = `image-${current.hash.replaceAll(':the:', '_').replaceAll(':', '_')}`;\n    const data = {\n      name: `${downloadPrefix}-c${current.camera}.png`,\n      download: downloadCallback,\n      downloadNumber: downloadNumber,\n      data: gl.canvas.toDataURL(),\n    };\n    passImageUp(data);\n  }\n}\n\nconst genSelString = (seed) => {\n  const repoIndex = (0,_theming__WEBPACK_IMPORTED_MODULE_1__.indexesOfMinRepo)(w.repo.models);\n  console.log('genSelString ~ repoIndex', repoIndex);\n  const { allSel } = (0,_theming__WEBPACK_IMPORTED_MODULE_1__.selectionFromHash)(seed, repoIndex);\n  return (0,_theming__WEBPACK_IMPORTED_MODULE_1__.selToSelString)(allSel);\n};\n\nfunction setNext(params) {\n  const replacement = { ...current, ...(next || {}), ...params };\n  if (\n    replacement.camera === current.camera &&\n    replacement.voxelSize === current.voxelSize &&\n    replacement.hash === current.hash &&\n    replacement.models === current.models\n  )\n    return;\n\n  next = replacement;\n}\n\nw.addEventListener('message', async (event) => {\n  switch (event.data.name) {\n    case 'e-models':\n      setNext({ models: event.data.models });\n      break;\n\n    case 'e-image':\n      downloadNumber = 'notdefined';\n      downloadCallback = false;\n      saveFrame = true;\n      break;\n\n    case 'e-down':\n      // console.log('w.addEventListener ~ event.data', event.data);\n      downloadNumber = event.data.number;\n      downloadCallback = true;\n      saveFrame = true;\n      break;\n\n    case 'e-seed':\n      w.seed = event.data.seed;\n      setNext({ hash: genSelString(event.data.seed) });\n      break;\n\n    // return data using in render\n    case 'e-data': {\n      const repoIndex = (0,_theming__WEBPACK_IMPORTED_MODULE_1__.indexesOfMinRepo)(w.repo.models);\n      const message = {\n        name: 'v-data',\n        models: w.models,\n        seed: w.seed,\n        repoIndex: (0,_theming__WEBPACK_IMPORTED_MODULE_1__.indexesOfMinRepo)(w.repo.models),\n        sel: (0,_theming__WEBPACK_IMPORTED_MODULE_1__.selectionFromHash)(w.seed, repoIndex),\n        camera: current.camera,\n        voxelSize: current.voxelSize,\n      };\n      parent.postMessage(message, '*');\n      break;\n    }\n\n    // set seleceted and seed\n    case 'e-sel': {\n      w.seed = event.data.seed;\n\n      const selArry = [];\n      for (const name in event.data.selected) {\n        selArry.push(`${name}:the:${event.data.selected[name]}`);\n      }\n      for (const name in event.data.themeFor) {\n        selArry.push(`theme:${name}:${event.data.themeFor[name]}`);\n      }\n      selArry.push(`sky:${event.data.sky}`);\n\n      setNext({ hash: selArry.join('-') });\n      break;\n    }\n\n    // set camera location\n    case 'e-loc': {\n      current.camera = 7;\n      state?.setCamera(current.camera);\n      window.locX = event.data.locX;\n      window.locY = event.data.locY;\n      window.locZ = event.data.locZ;\n\n      break;\n    }\n\n    // set camera number\n    case 'e-cam':\n      current.camera = event.data.camera;\n      state?.setCamera(current.camera);\n      break;\n\n    // set voxel depth\n    case 'e-voxel':\n      setNext({ voxelSize: event.data.voxelSize });\n      break;\n  }\n});\n\n// render once on load using passed in query\nconst seedUsed = getQueryVariable('seed') || w.seed;\n\ncurrent = {\n  camera: parseInt(getQueryVariable('cam')) || 7,\n  voxelSize: parseInt(getQueryVariable('vox')) || 6,\n  hash: genSelString(seedUsed),\n  models: w.models,\n  modelDepth: parseInt(getQueryVariable('mod')) || 10, // 10 is more than we have rn\n};\n\nconsole.log('Viewer Seed', seedUsed);\nconsole.log('Viewer Camera', current.camera);\n\nlet removeImage = () => {\n  var previewImage = document.getElementById('preview');\n  previewImage.parentNode.removeChild(previewImage);\n};\n\nlet clickToShow = () => {\n  removeImage();\n  window.renderSelected();\n};\nwindow.clickToShow = clickToShow;\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/oct.js?");

/***/ }),

/***/ "./src/octree/orbit.js":
/*!*****************************!*\
  !*** ./src/octree/orbit.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setup\": () => (/* binding */ setup),\n/* harmony export */   \"update\": () => (/* binding */ update)\n/* harmony export */ });\n/* global vec, sub, mul, vecToArray, add */\n\nlet w = window;\n\nconst config = { el: null, reversed: false };\nconst orbit = {\n  pos: vec(0, 10, 0),\n  lookAt: vec(0, 1.5, 0),\n  zoom: 6,\n};\nlet state = null;\nlet rotateStart = null;\nconst rotateSpeed = 0.5;\nconst sphericalDelta = { radius: 1, phi: 0, theta: 0 };\nconst sphericalTarget = {\n  radius: 40, // distance to the target at start\n  phi: Math.PI / 2, // rotation\n  theta: -Math.PI / 2, // -Math.PI / 4, // going around it\n};\nconst spherical = { radius: 1, phi: 0, theta: 0 };\n// const panDelta = vec(0,0,0);\nconst minAzimuthAngle = -Infinity;\nconst maxAzimuthAngle = Infinity;\nconst minPolarAngle = 0.1;\nconst maxPolarAngle = (Math.PI * 2) / 3;\nconst ease = 0.25;\nlet panDelta = vec(0, 0, 0);\nlet offset = vec(0, 0, 0);\nconst minDistance = 20;\nconst maxDistance = 60;\nlet target = vec(0, 2, -0.5);\nconst inertia = 0.85 / 10;\nconst zoomSpeed = 1;\n\nfunction clamp(x, min, max) {\n  return Math.max(min, Math.min(max, x));\n}\n\nfunction update() {\n  //  if (state === null) return;\n\n  // apply delta\n  sphericalTarget.radius *= sphericalDelta.radius;\n  sphericalTarget.theta += sphericalDelta.theta;\n  sphericalTarget.phi += sphericalDelta.phi;\n\n  // apply boundaries\n  sphericalTarget.theta = clamp(sphericalTarget.theta, minAzimuthAngle, maxAzimuthAngle);\n  sphericalTarget.phi = clamp(sphericalTarget.phi, minPolarAngle, maxPolarAngle);\n  sphericalTarget.radius = clamp(sphericalTarget.radius, minDistance, maxDistance);\n\n  // ease values\n  spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n  spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n  spherical.radius += (sphericalTarget.radius - spherical.radius) * ease;\n\n  // apply pan to target. As offset is relative to target, it also shifts\n  target = add(target, panDelta);\n\n  // apply rotation to offset\n  let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n  offset.x = sinPhiRadius * Math.cos(spherical.theta);\n  offset.y = spherical.radius * Math.cos(spherical.phi);\n  offset.z = sinPhiRadius * Math.sin(spherical.theta);\n\n  // Apply updated values to object\n  orbit.pos = add(target, offset);\n  orbit.lookAt = vec(...vecToArray(target));\n\n  // Apply inertia to values\n  sphericalDelta.theta *= inertia;\n  sphericalDelta.phi *= inertia;\n  panDelta = mul(panDelta, inertia);\n\n  // Reset scale every frame to avoid applying scale multiple times\n  sphericalDelta.radius = 1;\n}\n\nfunction handleMoveRotate(x, y) {\n  const tempVec2a = vec(x, y, 0);\n  const tempVec2b = mul(sub(tempVec2a, rotateStart), rotateSpeed);\n  let el = config.el === document ? document.body : config.el;\n  sphericalDelta.theta -=\n    ((config.reversed ? -1 : 1) * (2 * Math.PI * tempVec2b.x)) / el.clientHeight;\n  sphericalDelta.phi -= (2 * Math.PI * tempVec2b.y) / el.clientHeight;\n  rotateStart = tempVec2a;\n}\n\nfunction onMouseDown(e) {\n  switch (e.button) {\n    case 0:\n      rotateStart = vec(e.clientX, e.clientY, 0);\n      state = 0;\n      break;\n    // case this.mouseButtons.ZOOM:\n    //     if (enableZoom === false) return;\n    //     dollyStart.set(e.clientX, e.clientY);\n    //     state = STATE.DOLLY;\n    //     break;\n    // case this.mouseButtons.PAN:\n    //     if (enablePan === false) return;\n    //     panStart.set(e.clientX, e.clientY);\n    //     state = STATE.PAN;\n    //     break;\n  }\n\n  if (state !== null) {\n    w.addEventListener('mousemove', onMouseMove, false);\n    w.addEventListener('mouseup', onMouseUp, false);\n  }\n}\n\nfunction onTouchDown(e) {\n  if (e.touches.length > 0) {\n    const touch = e.touches[0];\n    rotateStart = vec(touch.screenX, touch.screenY, 0);\n    state = 0;\n  }\n\n  if (state !== null) {\n    w.addEventListener('touchmove', onTouchMove, false);\n    w.addEventListener('touchup', onTouchEnd, false);\n  }\n}\n\nfunction onMouseMove(e) {\n  if (state === 0) {\n    handleMoveRotate(e.clientX, e.clientY);\n  }\n}\n\nfunction onTouchMove(e) {\n  if (e.touches.length > 0) {\n    const touch = e.touches[0];\n    handleMoveRotate(touch.screenX, touch.screenY);\n  }\n\n  e.preventDefault();\n  e.stopPropagation();\n}\n\nfunction dolly(dollyScale) {\n  sphericalDelta.radius /= dollyScale;\n}\n\nfunction getZoomScale() {\n  return Math.pow(0.95, zoomSpeed);\n}\n\nfunction onMouseWheel(e) {\n  //   if (state === null) return;\n  e.stopPropagation();\n  e.preventDefault();\n\n  if (e.deltaY < 0) {\n    dolly(1 / getZoomScale());\n  } else if (e.deltaY > 0) {\n    dolly(getZoomScale());\n  }\n}\n\nfunction onMouseUp() {\n  w.removeEventListener('mousemove', onMouseMove, false);\n  w.removeEventListener('mouseup', onMouseUp, false);\n  state = null;\n}\n\nfunction onTouchEnd() {\n  w.removeEventListener('touchmove', onTouchMove, false);\n  w.removeEventListener('touchup', onTouchEnd, false);\n  state = null;\n}\n\nfunction setup(reversed = false) {\n  const el = document;\n\n  config.el = el;\n  config.reversed = reversed;\n\n  el.addEventListener('mousedown', onMouseDown, false);\n  el.addEventListener('wheel', onMouseWheel, { passive: false });\n\n  el.addEventListener('touchstart', onTouchDown);\n  el.addEventListener('touchend', onTouchEnd);\n  el.addEventListener('touchcancel', onTouchEnd);\n  el.addEventListener('touchmove', onTouchMove, { passive: false });\n\n  return orbit;\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/orbit.js?");

/***/ }),

/***/ "./src/octree/raymarch-octree/build-raymarch-octree.js":
/*!*************************************************************!*\
  !*** ./src/octree/raymarch-octree/build-raymarch-octree.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"build\": () => (/* binding */ build)\n/* harmony export */ });\n/* harmony import */ var _octree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./octree */ \"./src/octree/raymarch-octree/octree.js\");\n/* harmony import */ var _raymarcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raymarcher */ \"./src/octree/raymarch-octree/raymarcher.js\");\n/* harmony import */ var _theming__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../theming */ \"./src/theming.js\");\n/* global setupRepoModels, buildRepo, strokesToData */\n\n\n\n\n\nlet w = window;\n\nasync function build(hash, cameraChoice, voxelSize, sceneBounds, afterRender, modelDepth) {\n  setupRepoModels();\n\n  const repo = w.repo;\n\n  const fullRender = modelDepth > 4;\n  const { strokes } = buildRepo(hash, false, fullRender);\n\n  const partMaterialsCount = {};\n  for (let partName of _theming__WEBPACK_IMPORTED_MODULE_2__.allParts) {\n    partMaterialsCount[partName] = {};\n  }\n\n  for (let layer of strokes[0].part) {\n    for (let strokeIndex = 0; strokeIndex < layer.strokes.length; strokeIndex++) {\n      const stroke = layer.strokes[strokeIndex];\n      if (stroke.primitive !== 'attach' && stroke.mode !== 'sub') {\n        if (partMaterialsCount[stroke.partName][stroke.material] === undefined) {\n          partMaterialsCount[stroke.partName][stroke.material] = 0;\n        }\n        partMaterialsCount[stroke.partName][stroke.material] += 1;\n      }\n    }\n  }\n\n  const partMaterialsTrueOrder = {};\n  for (let partName of _theming__WEBPACK_IMPORTED_MODULE_2__.allParts) {\n    partMaterialsTrueOrder[partName] = Object.entries(partMaterialsCount[partName]);\n    partMaterialsTrueOrder[partName] = partMaterialsTrueOrder[partName].sort((a, b) => b[1] - a[1]);\n    partMaterialsTrueOrder[partName] = partMaterialsTrueOrder[partName].map(([material, i]) => {\n      return [parseInt(material, 10), i];\n    });\n  }\n\n  const normalHash = {};\n  const themeHash = {};\n  let skySel = 0;\n  hash.split('-').map((key) => {\n    const s = key.split(':');\n    if (key.indexOf('theme') !== -1) {\n      themeHash[s[1]] = parseInt(s[2]);\n    } else if (key.indexOf('sky') !== -1) {\n      skySel = parseInt(s[1]);\n    } else {\n      normalHash[s[0]] = parseInt(s[2]);\n    }\n  });\n\n  const topSkyColor = _theming__WEBPACK_IMPORTED_MODULE_2__.skyThemes[skySel][1];\n  const bottomSkyColor = _theming__WEBPACK_IMPORTED_MODULE_2__.skyThemes[skySel][0];\n\n  // changes colors for themes deterministically\n  const strokesThemed = strokes[0].part.map((part) => {\n    const partName = part.strokes[0].partName;\n\n    // get default stroke color for theme\n    let partColorSource = partMaterialsTrueOrder[partName].map(([material]) => {\n      return material;\n    });\n    // .map(([material]) => {\n    //   return parseInt(material, 10);\n    // });\n    const materialsCount = partColorSource.length;\n\n    // decided not to do clever things for complex models\n    // use explicit colors for complex models\n    let customColorKey = false;\n    let sourceIndexes = [];\n    if (partName === 'ground') {\n      if (normalHash['ground'] === 2) {\n        sourceIndexes = [3, 1, 2];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 6) {\n        sourceIndexes = [1, 2, 3];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 7) {\n        sourceIndexes = [0, 1, 3];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 9) {\n        sourceIndexes = [3, 4, 5];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 10) {\n        sourceIndexes = [1, 2, 3];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 12) {\n        sourceIndexes = [1, 2, 3];\n        customColorKey = true;\n      } else if (normalHash['ground'] === 15) {\n        sourceIndexes = [0, 1, 3];\n        customColorKey = true;\n      }\n    } else if (partName === 'hand') {\n      switch (normalHash['hand']) {\n        case 1:\n          sourceIndexes = [3, 1, 2];\n          customColorKey = true;\n          break;\n        case 4:\n          sourceIndexes = [0, 1];\n          customColorKey = true;\n          break;\n        case 5:\n          sourceIndexes = [0, 1];\n          customColorKey = true;\n          break;\n        case 8:\n          sourceIndexes = [4, 5];\n          customColorKey = true;\n          break;\n        // hand not themed\n      }\n    } else if (partName === 'floor') {\n      switch (normalHash['floor']) {\n        case 1:\n          sourceIndexes = [1, 3];\n          customColorKey = true;\n          break;\n        // floor not themed\n      }\n    }\n\n    if (customColorKey) {\n      partColorSource = sourceIndexes.map((index) => {\n        return partMaterialsTrueOrder[partName][index][0];\n      });\n    }\n\n    part.strokes = part.strokes.map((stroke) => {\n      const themeNumber = themeHash[partName];\n      if (themeNumber === undefined) {\n        return stroke;\n      }\n\n      const themeMaterials = _theming__WEBPACK_IMPORTED_MODULE_2__.themesMin[themeNumber] || [];\n\n      if (materialsCount <= themeMaterials.length || customColorKey) {\n        if (partColorSource[0] == stroke.material) {\n          stroke.material = themeMaterials[0];\n        } else if (partColorSource[1] == stroke.material) {\n          stroke.material = themeMaterials[1];\n        } else if (partColorSource[2] == stroke.material) {\n          stroke.material = themeMaterials[2];\n        }\n        //  else {\n        //   const a = partColorSource.indexOf(stroke.material);\n        //   if (a > -1) {\n        //     console.log('part.strokes=part.strokes.map ~ a', a);\n        //     stroke.material = themeMaterials[a % 3];\n        //   }\n        // }\n      }\n\n      return stroke;\n    });\n\n    return part;\n  });\n\n  const materialsUsed = [];\n  strokesThemed.forEach((part) => {\n    part.strokes.map((stroke) => {\n      materialsUsed.push(stroke.material);\n    });\n  });\n\n  const uniqueMaterialsUsed = [...new Set(materialsUsed)].sort((a, b) => a - b);\n  const materialTranslation = {};\n  let i = 0;\n  for (let material of uniqueMaterialsUsed) {\n    materialTranslation[material] = i;\n    i++;\n  }\n\n  const hardcodedColors = repo.hardcoded;\n  const randomColors = repo.randomized[0];\n\n  const minColors = [];\n  for (let i = 0; i < uniqueMaterialsUsed.length; i++) {\n    const sourceMaterial = uniqueMaterialsUsed[i];\n    if (sourceMaterial < 10000) {\n      const color = hardcodedColors[(sourceMaterial - 1) / 10];\n      minColors.push(color);\n    } else {\n      const color = randomColors[(sourceMaterial - 10000 - 1) / 10];\n      minColors.push(color);\n    }\n  }\n\n  // there is one missing color. need to remind myself how chris does special values\n  minColors[0] = hardcodedColors[0];\n\n  const strokesMinColors = strokesThemed.map((part) => {\n    part.strokes = part.strokes.map((stroke) => {\n      stroke.material = materialTranslation[stroke.material.toString()] * 10 + 1;\n      return stroke;\n    });\n    return part;\n  });\n\n  // prepares for shader\n  const strokesData = strokesToData(strokesMinColors);\n\n  const canvas = document.createElement('canvas');\n  document.body.appendChild(canvas);\n\n  const gl = canvas.getContext('webgl2', {\n    antialias: false,\n    depth: false,\n    scissor: false,\n  });\n\n  // use strokes to generate a octree of all the voxel data\n  const context = {};\n  const treeData = await _octree__WEBPACK_IMPORTED_MODULE_0__.build(\n    gl,\n    strokesData,\n    sceneBounds.min,\n    sceneBounds.max,\n    voxelSize,\n    context,\n  );\n\n  // run the display shader\n  const pixelScale = 1;\n  const { main, setCamera, stop } = (0,_raymarcher__WEBPACK_IMPORTED_MODULE_1__.runScene)(\n    gl,\n    canvas,\n    pixelScale,\n    repo,\n    treeData,\n    strokesData,\n    sceneBounds.min,\n    sceneBounds.max,\n    cameraChoice,\n    afterRender,\n    minColors,\n    topSkyColor,\n    bottomSkyColor,\n  );\n\n  main();\n\n  return { setCamera, stop, canvas, gl };\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/raymarch-octree/build-raymarch-octree.js?");

/***/ }),

/***/ "./src/octree/raymarch-octree/octree.js":
/*!**********************************************!*\
  !*** ./src/octree/raymarch-octree/octree.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"build\": () => (/* binding */ build)\n/* harmony export */ });\n/* harmony import */ var _gl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gl.js */ \"./src/octree/gl.js\");\n/* global vecToArray, sub, div, add */\n\n\n\nconst bytesPerFloat = 4;\nconst floatsPerVec4 = 4;\n\nasync function build(\n  gl,\n  strokesData,\n  boundsMin,\n  boundsMax,\n  maxDepth,\n  context,\n  doubleMaxDepth = false,\n) {\n  const vertex = window.shaders.octreeVertex;\n\n  await (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.fence)(gl);\n\n  // console.timeLog('octree');\n\n  const fs = `#version 300 es\n  precision highp float;\n  void main() {\n  }\n  `;\n\n  const boundsSizeVec = sub(boundsMax, boundsMin);\n  const center = add(boundsMin, div(boundsSizeVec, 2));\n\n  // console.log({ boundsMin, boundsMax, boundsSizeVec, center });\n\n  const outNodes = context.outNodes || new Float32Array(20000000);\n  outNodes[0] = 1;\n  outNodes[1] = 99;\n  outNodes[2] = 99;\n  outNodes[3] = 99;\n  const inNodes = context.inNodes || new Float32Array(20000000);\n  inNodes[0] = center.x;\n  inNodes[1] = center.y;\n  inNodes[2] = center.z;\n  inNodes[3] = -1;\n\n  let outTreeIndex = 1;\n  let freeOutTreeIndex = outTreeIndex + 8 * 1;\n\n  let depth = 0;\n  let inNodeCount = 1;\n\n  const nodeCountMax = 5000000;\n  let nodeIndexBuffer = context.nodeIndexBuffer;\n  if (!nodeIndexBuffer) {\n    const nodeIndexData = new Float32Array(nodeCountMax);\n    for (let i = 0; i < nodeCountMax; i++) {\n      nodeIndexData[i] = i;\n    }\n    nodeIndexBuffer = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.makeBuffer)(gl, nodeCountMax * bytesPerFloat, nodeIndexData);\n  }\n\n  const program =\n    context.program ||\n    (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.createProgram)(gl, vertex, fs, (program) => {\n      gl.transformFeedbackVaryings(\n        program,\n        ['oNode', 'oResult', 'oCoord', 'oNormal'],\n        gl.SEPARATE_ATTRIBS,\n      );\n    });\n\n  const bufferSize = nodeCountMax * floatsPerVec4 * bytesPerFloat;\n\n  const nodeBuffer = context.nodeBuffer || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.makeBuffer)(gl, bufferSize, [1, 0, 0, 0]);\n  const resultBuffer = context.resultBuffer || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.makeBuffer)(gl, bufferSize, [1, 0, 0, 0]);\n  const coordBuffer =\n    context.coordBuffer || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.makeBuffer)(gl, bufferSize, [...vecToArray(center), 99]);\n  const normalBuffer = context.normalBuffer || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.makeBuffer)(gl, bufferSize, [0, 0, 0, 0]);\n\n  const nodeOutBufferData =\n    context.nodeOutBufferData || new Float32Array(nodeCountMax * floatsPerVec4);\n  const coordOutBufferData =\n    context.coordOutBufferData || new Float32Array(nodeCountMax * floatsPerVec4);\n\n  const tf = context.tf || gl.createTransformFeedback();\n\n  const treeTex = context.treeTex || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, inNodes, 2048, 2048);\n  // if (context.treeTex) {\n  //   copyArrayToTexture(gl, inNodes, treeTex);\n  // }\n\n  const vao = context.vao || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.setupIndexVao)(gl, program, nodeIndexBuffer, 'iNodeIndex');\n\n  await (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.fence)(gl);\n\n  // console.timeLog('octree');\n\n  const strokesTex = context.strokesTex || (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, strokesData, 2048, 16);\n  if (context.strokesTex) {\n    (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.copyArrayToTexture)(gl, strokesData, strokesTex, (strokesData[0] * 28) / 4);\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n  await (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.fence)(gl);\n\n  // console.timeLog('octree');\n\n  // above this line is setup\n  // ---------------------------------\n  // below this line is \"render\" time\n\n  gl.enable(gl.RASTERIZER_DISCARD);\n\n  gl.useProgram(program);\n  gl.bindVertexArray(vao);\n\n  for (depth = 0; depth <= maxDepth; depth += 1) {\n    const nodeCount = inNodeCount * 8;\n\n    (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.setUniforms)(gl, program, [\n      ['uDepth', '1i', depth],\n      ['uBoundsSize', '3fv', vecToArray(boundsSizeVec)],\n      ['uMaxDepth', '1i', maxDepth],\n      ['uDoubleMaxDepth', '1i', doubleMaxDepth ? 1 : 0],\n      ['iTime', '1i', 0],\n      ['uTreeTex', '1i', 0],\n      ['uStrokesTex', '1i', 1],\n    ]);\n\n    (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.copyArrayToTexture)(gl, inNodes, treeTex, nodeCount);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, treeTex);\n\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, strokesTex);\n\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);\n\n    const bufOffset = outTreeIndex * floatsPerVec4 * bytesPerFloat;\n    const bufSize = nodeCount * floatsPerVec4 * bytesPerFloat;\n    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, nodeBuffer);\n    gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 1, resultBuffer, bufOffset, bufSize);\n    gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 2, coordBuffer, bufOffset, bufSize);\n    gl.bindBufferRange(gl.TRANSFORM_FEEDBACK_BUFFER, 3, normalBuffer, bufOffset, bufSize);\n\n    gl.beginTransformFeedback(gl.POINTS);\n    gl.drawArrays(gl.POINTS, 0, nodeCount);\n    gl.endTransformFeedback();\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n    await (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.fence)(gl);\n\n    // console.timeLog('octree');\n\n    let currTreeIndex = outTreeIndex;\n    let nextNodeCount = 0;\n    // let leaves = 0;\n\n    const nodeOut = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.readBuffer)(gl, nodeBuffer, nodeOutBufferData, 0, nodeCount * floatsPerVec4);\n    const coordOut = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.readBuffer)(\n      gl,\n      coordBuffer,\n      coordOutBufferData,\n      bufOffset,\n      nodeCount * floatsPerVec4,\n    );\n\n    for (let i = 0; i < nodeCount; i++) {\n      const nodeType = nodeOut[i * 4 + 0];\n      const coord = [coordOut[i * 4 + 0], coordOut[i * 4 + 1], coordOut[i * 4 + 2]];\n\n      // if (nodeType == 0) {\n      //   leaves += 1;\n      // }\n\n      outNodes[currTreeIndex * 4 + 0] =\n        nodeType > 0.1 // recurse\n          ? freeOutTreeIndex\n          : nodeType < -0.1 // dead\n          ? -1\n          : 0; // leaf\n      outNodes[currTreeIndex * 4 + 1] = 99;\n      outNodes[currTreeIndex * 4 + 2] = 99;\n      outNodes[currTreeIndex * 4 + 3] = 99;\n      currTreeIndex += 1;\n\n      if (nodeType > 0.1) {\n        //   if ((depth < maxDepth && nodeType > 0.1) || (depth === maxDepth && nodeType === 0)) {\n        freeOutTreeIndex += 8;\n        if (depth < maxDepth) {\n          inNodes[nextNodeCount * 4 + 0] = coord[0];\n          inNodes[nextNodeCount * 4 + 1] = coord[1];\n          inNodes[nextNodeCount * 4 + 2] = coord[2];\n          inNodes[nextNodeCount * 4 + 3] = 1;\n          nextNodeCount += 1;\n        }\n      }\n    }\n\n    // console.log({\n    //   depth,\n    //   nextNodeCount,\n    //   leaves,\n    // });\n    // console.log({ nodeOut: nodeOut.slice(0, nodeCount * 4) });\n    // console.log({ inNodes: inNodes.slice(0, nextNodeCount * 4) });\n    outTreeIndex = currTreeIndex;\n    // if (depth < maxDepth) {\n    inNodeCount = nextNodeCount;\n    // }\n\n    // console.timeLog('octree');\n  }\n\n  gl.useProgram(null);\n  gl.bindVertexArray(null);\n\n  gl.disable(gl.RASTERIZER_DISCARD);\n\n  Object.assign(context, {\n    outNodes,\n    inNodes,\n    program,\n    tf,\n    strokesTex,\n    treeTex,\n    nodeOutBufferData,\n    coordOutBufferData,\n    nodeBuffer,\n    resultBuffer,\n    coordBuffer,\n    normalBuffer,\n    vao,\n    nodeIndexBuffer,\n  });\n\n  // console.timeLog('octree');\n\n  return { inNodeCount, nodeBuffer, resultBuffer, normalBuffer, coordBuffer, outNodes };\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/raymarch-octree/octree.js?");

/***/ }),

/***/ "./src/octree/raymarch-octree/raymarcher.js":
/*!**************************************************!*\
  !*** ./src/octree/raymarch-octree/raymarcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"runScene\": () => (/* binding */ runScene)\n/* harmony export */ });\n/* harmony import */ var _gl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gl.js */ \"./src/octree/gl.js\");\n/* harmony import */ var _camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../camera.js */ \"./src/octree/camera.js\");\n/* harmony import */ var _orbit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../orbit.js */ \"./src/octree/orbit.js\");\n/* global vecToArray */\n\n\n\n\n\n\nlet w = window;\n\nfunction runScene(\n  gl,\n  canvas,\n  pixelScale,\n  repo,\n  treeData,\n  strokesData,\n  boundsMin,\n  boundsMax,\n  cameraChoice,\n  afterRender,\n  colors,\n  topSkyColor,\n  bottomSkyColor,\n) {\n  const char = canvas;\n\n  // moved this out of the shader so minification works\n  // in vec2 uv;\n\n  const vertex = `\\\n#version 300 es\nin vec2 position;\nout vec2 fragCoord;\nvoid main(){\n  gl_Position=vec4(position,0,1);\n  fragCoord=position;\n}`;\n\n  let fragment = w.shaders.raymarcherFragment;\n\n  let iFrame = 0;\n\n  const charCanvas = gl;\n\n  let program;\n  let iMouse = [0, 0, 0, 0];\n  let lastClick = [0, 0, -99, 0];\n\n  let o = 0;\n  let f = new Date() / 1e3;\n  let d = 0;\n\n  let y = 0;\n\n  let setup;\n\n  _camera_js__WEBPACK_IMPORTED_MODULE_1__.setOrbit(_orbit_js__WEBPACK_IMPORTED_MODULE_2__.setup());\n  _camera_js__WEBPACK_IMPORTED_MODULE_1__.setChoice(cameraChoice);\n\n  let keepGoing = true;\n  const stop = () => {\n    keepGoing = false;\n  };\n\n  const main = () => {\n    setup = () => {\n      program = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.createProgram)(gl, vertex, fragment);\n      gl.useProgram(program);\n\n      const { outNodes, resultBuffer, normalBuffer } = treeData;\n      let treeTex = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, outNodes, 2048, 2048);\n      let resultTex = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, null, 2048, 2048);\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.copyBufferToTexture)(gl, resultBuffer, resultTex, 0);\n      let normalTex = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, null, 2048, 2048);\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.copyBufferToTexture)(gl, normalBuffer, normalTex, 0);\n      let strokesTex = (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.textureFromPixelArray)(gl, strokesData, 1024, 16);\n\n      // outNodes.splice(0);\n      gl.deleteBuffer(resultBuffer);\n      gl.deleteBuffer(normalBuffer);\n\n      const cam = _camera_js__WEBPACK_IMPORTED_MODULE_1__.update();\n\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.setUniforms)(\n        gl,\n        program,\n        [\n          ['uColors', '3fv', colors.flat()],\n          [\n            'uMaterials',\n            '4fv',\n            repo.mats.map((mat) => [mat.roughness, mat.metalness, 0, 0]).flat(),\n          ],\n          ['uBoundsMin', '3fv', vecToArray(boundsMin)],\n          ['uBoundsMax', '3fv', vecToArray(boundsMax)],\n          ['iTreeTex', '1i', 0],\n          ['iStrokesTex', '1i', 1],\n          ['uResultTex', '1i', 2],\n          ['uNormalTex', '1i', 3],\n          ['uCameraPos', '3fv', vecToArray(cam.pos)],\n          ['uCameraLookAt', '3fv', vecToArray(cam.lookAt)],\n          ['uCameraZoom', '1f', cam.zoom],\n          ['uBackgroundColor1', '3fv', topSkyColor],\n          ['uBackgroundColor2', '3fv', bottomSkyColor],\n        ],\n        true,\n      );\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, treeTex);\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, strokesTex);\n      gl.activeTexture(gl.TEXTURE2);\n      gl.bindTexture(gl.TEXTURE_2D, resultTex);\n      gl.activeTexture(gl.TEXTURE3);\n      gl.bindTexture(gl.TEXTURE_2D, normalTex);\n\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.setupFullscreenTriangle)(gl);\n\n      charCanvas.clearColor(1, 0, 0, 1);\n      charCanvas.clear(charCanvas.COLOR_BUFFER_BIT);\n    };\n\n    oninput = setup;\n    setup();\n\n    function resize() {\n      let height = w.innerHeight;\n      let width = w.innerWidth;\n\n      canvas.width = width * pixelScale;\n      canvas.height = height * pixelScale;\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n    }\n    w.resize = resize;\n    w.addEventListener('resize', resize, false);\n    resize();\n\n    const frame = () => {\n      d = new Date() / 1e3 - f;\n      f = new Date() / 1e3;\n\n      _orbit_js__WEBPACK_IMPORTED_MODULE_2__.update();\n      const cam = _camera_js__WEBPACK_IMPORTED_MODULE_1__.update();\n\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.setUniforms)(gl, program, [\n        ['iTimeDelta', '1f', d],\n        ['iTime', '1f', (o += d)],\n        ['iFrame', '1i', iFrame++],\n        ['iDate', '1f', ~~f],\n        ['iMouse', '4fv', iMouse],\n        ['iResolution', '2fv', [gl.drawingBufferWidth, gl.drawingBufferHeight]],\n        ['iLastClick', '4fv', lastClick],\n        ['uCameraPos', '3fv', vecToArray(cam.pos)],\n        ['uCameraLookAt', '3fv', vecToArray(cam.lookAt)],\n        ['uCameraZoom', '1f', cam.zoom],\n      ]);\n\n      (0,_gl_js__WEBPACK_IMPORTED_MODULE_0__.drawFullscreenTriangle)(gl);\n      afterRender(gl);\n\n      if (keepGoing) {\n        requestAnimationFrame(frame);\n      }\n    };\n    frame();\n\n    onmousedown = onmouseup = () => {\n      y ^= 1;\n    };\n\n    function getMousePos(canvas, evt) {\n      var rect = canvas.getBoundingClientRect();\n      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n    }\n\n    char.onmousemove = function (e) {\n      if (y) {\n        const pos = getMousePos(char, e);\n        (iMouse[0] = pos.x), (iMouse[1] = pos.y);\n      }\n    };\n\n    char.onclick = function (e) {\n      const pos = getMousePos(char, e);\n      (iMouse[2] = pos.x), (iMouse[3] = pos.y);\n      lastClick[0] = pos.x;\n      lastClick[1] = pos.y;\n      lastClick[2] = o;\n    };\n  };\n\n  onload = function () {\n    main();\n  };\n\n  function setCamera(choice) {\n    const duration = 0.5; // seconds\n    _camera_js__WEBPACK_IMPORTED_MODULE_1__.moveChoice(choice, duration); // lerp to new camera\n    // camera.setChoice(choice); // change camera immediately\n  }\n\n  return { main, setCamera, stop };\n}\n\n\n//# sourceURL=webpack://webpack-demo/./src/octree/raymarch-octree/raymarcher.js?");

/***/ }),

/***/ "./src/theming.js":
/*!************************!*\
  !*** ./src/theming.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const randomColors = [\n  [255, 171, 239], // pink 1\n  [255, 105, 202], // pink 2\n  [255, 0, 182], // pink 3\n\n  [191, 1, 28], // light maroon\n  [173, 5, 20], // mid maroon\n  [88, 1, 12], // dark maroon\n\n  [72, 115, 255], // blue\n  [134, 198, 231], // light blue\n  [26, 45, 89], // dark blue\n\n  [25, 117, 113], // green\n  [33, 92, 112], // light green\n  [3, 61, 76],\n\n  [243, 7, 19], // red\n  [248, 55, 103], // red 3\n  [0, 5, 10], // black\n\n  /// SECOND 5\n\n  [246, 235, 218], // beige\n  [215, 199, 178], // beige\n  [237, 221, 196], // beige\n\n  [255, 218, 77], // golden 1\n  [228, 169, 46], // golden 2\n  [226, 130, 32], // golden 3\n\n  [125, 54, 175], // purple 1\n  [99, 44, 155], // purple 2\n  [51, 9, 71], // purple 3\n\n  // orange\n  [255, 137, 44],\n  [241, 62, 0],\n  [253, 130, 23],\n\n  /// halfway\n\n  // white and black\n  [242, 242, 242], //whiteish\n  [26, 26, 26], // blackish\n  [252, 243, 240], //whitish 2\n\n  /// THIRD 5\n\n  // yellow and black\n  [242, 203, 4], // yellowish 1\n  [242, 183, 7], // yellowish 2\n  [26, 26, 26], // blackish 1\n\n  // light pink x2 & blue\n  [241, 189, 176], // light pink 1\n  [241, 208, 208], // light pink 2\n  [6, 136, 219], // light blue\n\n  // yellow and brown\n  [242, 203, 4], // yellowish 1\n  [64, 49, 40], // brown 1\n  [64, 36, 20], // brown 2\n\n  // brown and blue\n  [66, 67, 97], // blue 1\n  [134, 198, 231], // blue 2\n  [89, 15, 8], //brown 1\n\n  // light blue and dark blues\n  [228, 235, 242], // light blue 1\n  [134, 198, 231], // light blue 2\n  [26, 45, 89], // dark blue 1\n];\n\n// 1. 4 , 8\n\nlet themesMin = [\n  [10001, 10011, 10021], // pink (done)\n  [10031, 10041, 10051], // maroon (done)\n  [10061, 10071, 10081], // blue (done)\n  [10091, 10101, 10111], // green (done)\n  [10121, 10131, 10141], // red + black (done)\n  /// SECOND 5\n  [10151, 10161, 10171], // beige (done)\n  [10181, 10191, 10201], // golden (done)\n  [10211, 10221, 10231], // purple (done)\n  [10241, 10251, 10261], // orange (done)\n  [10271, 10281, 10291], // white, black, white (done)\n  /// THIRD 5\n  [10301, 10311, 10321], // yellow and black (done)\n  [10331, 10341, 10351], // light pink and blue (done)\n  // [10361, 10371, 10381], // yellow and brown\n  [10391, 10401, 10411], // brown and blue\n  // [10421, 10431, 10441], // light blue and dark blue\n];\n\nlet skyThemes = [\n  // [\n  //   [0.697, 0.874, 0.969],\n  //   [0.62, 0.786, 0.965],\n  // ],\n  [\n    [0.6, 0.805, 1.0],\n    [0.6, 0.805, 1.0],\n  ],\n  [\n    [0.828, 0.848, 0.942],\n    [0.828, 0.848, 0.942],\n  ],\n  [\n    [0.614, 0.926, 0.998],\n    [0.614, 0.926, 0.998],\n  ],\n  [\n    [0.961, 0.914, 0.976],\n    [0.961, 0.914, 0.976],\n  ],\n  // [\n  //   [0.855, 0.931, 0.881],\n  //   [0.855, 0.931, 0.881],\n  // ],\n  // [\n  //   [0.872, 0.918, 0.871],\n  //   [0.872, 0.918, 0.871],\n  // ],\n  // [\n  //   [0.749, 0.589, 0.611],\n  //   [0.749, 0.589, 0.611],\n  // ],\n];\n\nconst allParts = [\n  'body',\n  'floor',\n  'glasses',\n  'shirt',\n  'ground',\n  'hand',\n  'headtop',\n  'neck',\n  'shoes',\n];\n\nconst themablePartNames = [\n  'floor',\n  'glasses',\n  'ground',\n  'hand',\n  'headtop',\n  'neck',\n  'shirt',\n  'shoes',\n];\nconst OPTIONAL_MODELS = ['hand', 'glasses', 'ground', 'headtop', 'shirt', 'neck'];\n\nconst percentOfSkippedModels = 15;\nconst percentOfTheme = 80;\nconst themeMatchPercent = 50;\n\nconst indexesOfMinRepo = (minRepo) => {\n  let indexes = {};\n  for (let name of allParts) {\n    indexes[name] = minRepo[name]\n      .filter((w) => !!w)\n      .map((w) => w.the.index)\n      .sort((a, b) => a - b);\n  }\n\n  // console.log('Repo Min Index: ', JSON.stringify(indexes));\n\n  return indexes;\n};\n\nconst indexesOfMaxRepo = (maxRepo) => {\n  let indexes = {};\n\n  for (let name in maxRepo) {\n    const s = name.split(':');\n    if (indexes[s[0]] == undefined) {\n      indexes[s[0]] = [];\n    }\n    // indexes[s[0]] ||= [];\n    indexes[s[0]].push(parseInt(s[2]));\n    indexes[s[0]] = indexes[s[0]].sort((a, b) => a - b);\n  }\n\n  // console.log('Repo Max Index: ', JSON.stringify(indexes));\n\n  return indexes;\n};\n\nconst selectionFromHash = (hash, repoModels) => {\n  const numbers = [];\n  const longHash = hash + hash + hash + hash + hash;\n\n  for (let i = 0; i < longHash.length; i += 7) {\n    const number = longHash.substr(i, 7);\n    numbers.push(parseInt(number, 16));\n  }\n\n  const allSel = {};\n  const sel = {};\n  const themeFor = {};\n\n  // random build of models\n  for (let name of allParts) {\n    const currentRandomNumber = numbers.pop();\n    const models = repoModels[name];\n    const modulo = currentRandomNumber % models.length;\n    allSel[name] = models[modulo];\n    sel[name] = models[modulo];\n  }\n\n  const themeMatch = numbers.pop() % themesMin.length;\n\n  for (let name of allParts) {\n    // theme choice\n    if (themablePartNames.indexOf(name) !== -1) {\n      const themeApplication = (numbers.pop() % 10) * 10 + (numbers.pop() % 10);\n      // apply a theme 80% of the time\n      if (themeApplication < percentOfTheme) {\n        if (themeApplication < themeMatchPercent) {\n          allSel[`theme:${name}`] = themeMatch;\n          themeFor[name] = themeMatch;\n        } else {\n          const themeUnique = numbers.pop() % themesMin.length;\n          allSel[`theme:${name}`] = themeUnique;\n          themeFor[name] = themeUnique;\n        }\n      }\n    }\n\n    // remove model 15% of the time\n    if (OPTIONAL_MODELS.indexOf(name) !== -1) {\n      const optionalModels = (numbers.pop() % 10) * 10 + (numbers.pop() % 10);\n      if (optionalModels < percentOfSkippedModels) {\n        delete allSel[name];\n        delete allSel[`theme:${name}`];\n        delete sel[name];\n        delete themeFor[name];\n      }\n    }\n  }\n\n  const skyRandom = numbers.pop();\n  const sky = skyRandom % skyThemes.length;\n  allSel.sky = sky;\n\n  for (const name in allSel) {\n    console.log('inside =>', name, allSel[name]);\n  }\n\n  return { allSel, sel, themeFor, sky };\n};\n\nconst selToSelString = (sel) => {\n  const selString = [];\n  for (const name in sel) {\n    if (name.indexOf('theme:') !== -1) {\n      selString.push(`${name}:${sel[name]}`);\n    } else if (name === 'sky') {\n      selString.push(`${name}:${sel[name]}`);\n    } else {\n      const selIndex = sel[name];\n      selString.push(`${name}:the:${selIndex}`);\n    }\n  }\n  return selString.join('-');\n};\n\nexports.allParts = allParts;\nexports.randomColors = randomColors;\n\nexports.themesMin = themesMin;\nexports.skyThemes = skyThemes;\n\nexports.themablePartNames = themablePartNames;\nexports.OPTIONAL_MODELS = OPTIONAL_MODELS;\n\nexports.percentOfSkippedModels = percentOfSkippedModels;\nexports.percentOfTheme = percentOfTheme;\n\nexports.indexesOfMinRepo = indexesOfMinRepo;\nexports.indexesOfMaxRepo = indexesOfMaxRepo;\n\nexports.selectionFromHash = selectionFromHash;\nexports.selToSelString = selToSelString;\n\n\n//# sourceURL=webpack://webpack-demo/./src/theming.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/octree/oct.js");
/******/ 	
/******/ })()
;