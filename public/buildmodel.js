/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/repo.js":
/*!*********************!*\
  !*** ./src/repo.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildRepo\": () => (/* binding */ buildRepo),\n/* harmony export */   \"strokesToData\": () => (/* binding */ strokesToData)\n/* harmony export */ });\nlet w = window;\n\nlet decodeNorm = (str) => {\n  const ENCODING = '0123456789+-.,;/';\n  const B64CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+=';\n\n  const bytes = str.split('').map((c) => B64CHARS.indexOf(c));\n  const out = [];\n  let bits = 0;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const byte1 = bytes[Math.floor(bits / 6)];\n    if (bits % 6 === 0) {\n      out.push(byte1 & 0b1111);\n    } else if (bits % 6 === 2) {\n      out.push((byte1 & 0b111100) >> 2);\n    } else {\n      const byte2 = bytes[Math.floor((bits + 4) / 6)];\n      out.push(((byte1 & 0b110000) >> 4) + ((byte2 & 0b11) << 2));\n    }\n    bits += 4;\n    if (Math.floor((bits + 2) / 6) >= bytes.length) break;\n  }\n\n  return out.map((n) => ENCODING[n]).join('');\n};\n\n// these map from norm -> compressed -> norm form\nconst SIDES = [\n  //'left', 'right',\n  'the',\n];\nconst PARTS = [\n  'arm',\n  'leg',\n  'mouth',\n  'eyes',\n  'body',\n  'ground',\n  'glasses',\n  'tat',\n  'shoes',\n  'mustache',\n  'headtop',\n  'hand',\n  'floor',\n  'neck',\n  'hat',\n  'shirt',\n];\nconst MODES = ['add', 'sub', 'int', 'rep'];\n\n///////////////////////////////////////////////////////////////////////////////\n// Parsers helpers\n///////////////////////////////////////////////////////////////////////////////\n\nlet inputSubstring = (input) => {\n  return input.string.substring(input.index);\n};\n\nlet parseBoolean = (input) => {\n  const bool = inputSubstring(input)[0] === '+';\n  input.index += 1;\n  return bool;\n};\n\nlet parseNumber = (input) => {\n  const str = inputSubstring(input);\n  let chars = str.match(/^[+-][\\d.]*/);\n  if (chars) {\n    chars = chars[0];\n    if (chars.length === 1) {\n      if (chars[0] === '+') {\n        input.index += 1;\n        return 0;\n      } else {\n        console.error('error parsing number', { input });\n      }\n    } else {\n      input.index += chars.length;\n      return parseFloat(chars);\n    }\n  } else {\n    console.error('error parsing number', { input });\n  }\n};\n\nconst PRIMITIVES = [\n  'attach',\n  'cube',\n  'cylinder',\n  'bezier',\n  'joint',\n  'sphere',\n  'triangle',\n  'polygon',\n];\n\nlet parsePrimitive = (input) => {\n  return PRIMITIVES[parseNumber(input)];\n};\n\nlet parseNumbers = (input, count) => {\n  const numbers = [];\n  for (let i = 0; i < count; i++) {\n    numbers.push(parseNumber(input));\n  }\n  return numbers;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Parse Stroke and Materials\n///////////////////////////////////////////////////////////////////////////////\n\nconst FIELD_NAMES = [\n  'blend',\n  'shell',\n  'hole',\n  'bevel',\n  'round',\n  'cone',\n  'lineWidth',\n  'vertexPosition',\n  'torus',\n  'mirrorX',\n  'material',\n  'blink',\n  'star',\n  'vertexCount',\n  'offsX',\n];\n\nconst FIELDS = {\n  cube: 'bshbrc__tmm___o',\n  cylinder: 'bsh_rc__tmm___o',\n  bezier: 'bsh_rclvtmm___o',\n  joint: 'bs___c__tmm___o',\n  sphere: 'bs_______mmb__o',\n  triangle: 'bshbrc_vtmm___o',\n  polygon: 'bshbrc____m_sn_',\n};\n\nconst FIELD_TYPES = 'nnnnnnnnbbnbnnn';\n\nlet parseStroke = (partName, input) => {\n  const primitive = parsePrimitive(input);\n  let stroke = { primitive };\n\n  FIELD_NAMES.forEach((field, i) => {\n    stroke[field] = FIELD_TYPES[i] === 'n' ? 0 : false;\n  });\n\n  if (primitive === 'attach') {\n    stroke = {\n      ...stroke,\n      partName,\n      attach: {\n        part: PARTS[parseNumber(input)],\n        side: SIDES[parseNumber(input)],\n      },\n      position: parseNumbers(input, 3),\n      rotation: [0, 0, 0],\n      size: [1, 1, 1],\n      blend: parseNumber(input),\n      material: 0,\n    };\n  } else {\n    stroke = {\n      ...stroke,\n      partName,\n      mode: MODES[parseNumber(input)],\n      position: parseNumbers(input, 3),\n      rotation: parseNumbers(input, 3),\n      size: parseNumbers(input, 3),\n    };\n\n    FIELD_NAMES.forEach((fieldName, i) => {\n      if (FIELDS[primitive][i] !== '_') {\n        stroke[fieldName] = (FIELD_TYPES[i] === 'n' ? parseNumber : parseBoolean)(input);\n      }\n    });\n\n    if (stroke.material < 0) {\n      stroke.material = -stroke.material + 10000;\n    }\n\n    // stroke material of 0 is actually the default material\n    // so every material is incremeted by 1\n    stroke.material += 1;\n  }\n  return stroke;\n};\n\nlet parseLayers = (partName, str) => {\n  return str.split(',').map((sLayer) => {\n    const input = { string: sLayer, index: 0 };\n    const subparts = [];\n    while (input.index < input.string.length) {\n      subparts.push(parseStroke(partName, input));\n    }\n    return { subparts };\n  });\n};\n\nfunction parseModels(_string) {\n  const parts = {};\n  _string.split(';').forEach((string) => {\n    const input = { string, index: 0 };\n    const part = PARTS[parseNumber(input)]; //parseInt(input.string[input.index++])];\n    const side = SIDES[parseNumber(input)]; //parseInt(input.string[input.index++])];\n    const index = parseNumber(input);\n    const bounds = [\n      [parseNumber(input), parseNumber(input), parseNumber(input)],\n      [parseNumber(input), parseNumber(input), parseNumber(input)],\n    ];\n    // console.log('parsing', { part, side, index });\n    const layers = parseLayers(part, input.string.substring(input.index));\n    parts[part] = parts[part] || [];\n    parts[part][index] = parts[part][index] || {};\n    parts[part][index][side] = {\n      part,\n      side,\n      index,\n      layers,\n      bounds,\n    };\n  });\n  return parts;\n}\n\nfunction parseMaterials(string) {\n  const input = { string, index: 0 };\n  const mats = [];\n  while (input.index < input.string.length) {\n    mats.push({\n      roughness: parseNumber(input),\n      metalness: parseNumber(input),\n    });\n  }\n  return mats;\n}\n\nfunction parsePalettes(_string) {\n  return _string.split(';').map((string) => {\n    const input = { string, index: 0 };\n    const pal = [];\n    while (input.index < input.string.length) {\n      pal.push([parseNumber(input), parseNumber(input), parseNumber(input)]);\n    }\n    return pal;\n  });\n}\n\nfunction parseRepo(min) {\n  const repo = decodeNorm(min);\n  // console.log({ repostr: repo });\n  const [_models, _mats, _hardcoded, _randomized] = repo.split('/');\n  return {\n    models: parseModels(_models),\n    mats: parseMaterials(_mats),\n    hardcoded: parsePalettes(_hardcoded)[0],\n    randomized: parsePalettes(_randomized),\n  };\n}\n\n// let allModelIndex = {};\n// for (let modelname in repo.models) {\n//   console.log('part', modelname);\n//   allModelIndex[modelname] = repo.models[modelname]\n//     .map((model) => {\n//       if (model) {\n//         return model.the.index;\n//       } else {\n//         return null;\n//       }\n//     })\n//     .filter((n) => n);\n// }\n// console.log('allModelIndex', JSON.stringify(allModelIndex));\n\nlet repo;\nlet partsParsed;\n\nconst setupRepoModels = () => {\n  repo = w.models ? parseRepo(w.models) : {};\n  w.repo = repo;\n  partsParsed = repo.models;\n};\n\nsetupRepoModels();\n\n///////////////////////////////////////////////////////////////////////////////\n// Decode Norm, Parse Layers, Build Norm\n///////////////////////////////////////////////////////////////////////////////\n\n// each part has layers\n// each layer has subparts or strokes (they are the same thing)\n// an object that is show (cube on sphere)\n\n// layer can be a bunch of objects or a single object (or stroke)\n// if layer name has a special \"attach\" in name, it is a attach point\n// the kind of attach point, is the other word in the name\n\n// the bull has a attach point called \"attach-eye\" or similar.\n// attach layer has 1 stoke which is position of attach point\n\n// we merge them together, there is an attach layer here. it is hat\n// pick select hat part and place it here, slice it on over list of layers\n\n// find object\n// transform layers/strokes of object (hat)\n// splice into overall list\n\nfunction invXformPoint(p) {\n  const xlate = [0, 0, 256 - 150];\n  p = p.map((x, i) => x - xlate[i]);\n  // const m = [1, 0, 0, 0, 0, -1, 0, 1, 0];\n  // p = [\n  //   m[0] * p[0] + m[3] * p[1] + m[6] * p[2],\n  //   m[1] * p[0] + m[4] * p[1] + m[7] * p[2],\n  //   m[2] * p[0] + m[5] * p[1] + m[8] * p[2],\n  // ];\n  p = [p[0], p[2], -p[1]];\n  p = p.map((x) => x / 150);\n  return p;\n}\n\nfunction extendBounds(bounds, other) {\n  return [\n    [\n      Math.min(bounds[0][0], other[0][0]),\n      Math.min(bounds[0][1], other[0][1]),\n      Math.min(bounds[0][2], other[0][2]),\n    ],\n    [\n      Math.max(bounds[1][0], other[1][0]),\n      Math.max(bounds[1][1], other[1][1]),\n      Math.max(bounds[1][2], other[1][2]),\n    ],\n  ];\n}\n\nlet addPosition = (a, b) => {\n  return a.map((x, i) => x + b[i]);\n};\n\nconst startPoint = 'floor';\n\nlet buildNorm = (selected, useSeparate) => {\n  setupRepoModels(); // reset layers each time for random reset\n\n  if (!selected[`${startPoint}:the`]) return;\n\n  const base = partsParsed[startPoint][selected[`${startPoint}:the`]].the;\n  const parts = [\n    {\n      part: base,\n      pos: invXformPoint([0, 0, 0]),\n      _pos: [0, 0, 0],\n      maxDepth: 0,\n    },\n  ];\n\n  // list of laers and materails\n  // each layer has list of subparts\n  // console.log('buildNorm ~ body', body);\n\n  // interate through possible things to attach from selected list\n  PARTS_LIST.forEach(({ part, side, separate, maxDepth }) => {\n    const key = `${part}:${side}`;\n\n    // model is one of the selected ones\n    if (selected[key]) {\n      let found = false;\n      for (let i = 0; i < parts.length; i++) {\n        // get model data\n        const thePart = partsParsed[part][selected[key]][side];\n\n        const base = parts[i].part;\n\n        // find attach point index on body model\n        let layerIndex = 0;\n        let strokeIndex = 0;\n        layerloop: for (; layerIndex < base.layers.length; layerIndex++) {\n          const layer = base.layers[layerIndex];\n          for (strokeIndex = 0; strokeIndex < layer.subparts.length; strokeIndex++) {\n            const stroke = layer.subparts[strokeIndex];\n            if (stroke.primitive === 'attach' && stroke.attach.part === part) {\n              break layerloop;\n            }\n          }\n        }\n\n        if (layerIndex < base.layers.length) {\n          found = true;\n          const relPos = base.layers[layerIndex].subparts[strokeIndex].position;\n\n          if (useSeparate && separate) {\n            const basePos = parts[i]._pos;\n            const relPos_ = relPos.map((x, i) => x + basePos[i]);\n            // console.log({\n            //   part,\n            //   basePos: basePos.map((x) => x.toFixed(1)).join(','),\n            //   relPos: relPos.map((x) => x.toFixed(1)).join(','),\n            //   relPos_: relPos_.map((x) => x.toFixed(1)).join(','),\n            //   pos: invXformPoint(relPos_)\n            //     .map((x) => x.toFixed(1))\n            //     .join(','),\n            // });\n            parts.push({\n              part: thePart,\n              pos: invXformPoint(relPos_),\n              _pos: relPos_,\n              maxDepth,\n            });\n          } else {\n            const newLayers = thePart.layers.map((layer) => {\n              return {\n                layer: {\n                  ...layer,\n                },\n                subparts: layer.subparts.map((subpart) => ({\n                  ...subpart,\n                  position: addPosition(subpart.position, relPos),\n                })),\n              };\n            });\n\n            base.layers.splice(layerIndex, 0, ...newLayers);\n            const xformedRelPos = invXformPoint(relPos);\n            base.bounds = extendBounds(base.bounds, [\n              addPosition(thePart.bounds[0], xformedRelPos),\n              addPosition(thePart.bounds[1], xformedRelPos),\n            ]);\n          }\n        }\n      }\n      if (!found) {\n        console.error('buildNorm: attach point not found', part, side);\n      }\n    }\n  });\n\n  return parts;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Build Selected Parts\n///////////////////////////////////////////////////////////////////////////////\n\nconst PARTS_LIST = [\n  { part: 'shoes', side: 'the', index: 0, coreModels: true },\n  { part: 'body', side: 'the', index: 3, separate: true, maxDepth: 0, coreModels: true },\n  { part: 'glasses', side: 'the', index: 0, separate: false, maxDepth: 0, coreModels: true },\n  { part: 'ground', side: 'the', index: 0, separate: false, maxDepth: 0, coreModels: true },\n  { part: 'hand', side: 'the', index: 0 },\n  { part: 'headtop', side: 'the', index: 0 },\n  { part: 'neck', side: 'the', index: 0 },\n  { part: 'shirt', side: 'the', index: 0 },\n];\n\nlet buildSelectedLongVersion = (hash, coreModels) => {\n  const sel = {};\n  let list = [];\n  if (coreModels == true) {\n    list = [\n      {\n        part: startPoint,\n        side: 'the',\n        ci: 0,\n      },\n      ...PARTS_LIST,\n    ];\n  } else {\n    list = [\n      {\n        part: startPoint,\n        side: 'the',\n        ci: 0,\n      },\n      ...PARTS_LIST.filter((x) => {\n        return x.coreModels == true;\n      }),\n    ];\n  }\n\n  const hashParts = hash.split('-');\n\n  list.forEach(({ part, side }) => {\n    // get the index we chose for this piece from the hash string\n    const hashPart = hashParts.find((str) => str.startsWith(`${part}:${side}:`));\n    if (!hashPart) return;\n    const [, , _index] = hashPart.split(':');\n    const index = parseInt(_index);\n\n    const key = `${part}:${side}`;\n    const _part = partsParsed[part];\n    if (_part) {\n      const hashIndex = index;\n      const partSide = _part[hashIndex][side];\n      if (partSide) {\n        const partIndex = partSide.index;\n        sel[key] = partIndex;\n      }\n    }\n  });\n\n  return sel;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Build Shader\n///////////////////////////////////////////////////////////////////////////////\n\nfunction strokesFromNorm(norm) {\n  return {\n    part: norm.part.layers\n      .filter((layer) => layer.subparts.length > 0)\n      .map((layer, layerIndex) => {\n        return {\n          layerIndex,\n          op: layer.subparts[0].mode,\n          blend: layer.subparts[0].blend,\n          strokes: layer.subparts,\n        };\n      }),\n    bounds: norm.part.bounds,\n    pos: norm.pos,\n    maxDepth: norm.maxDepth,\n  };\n}\n\nfunction strokesToData(layers) {\n  const data = new Float32Array(1000000);\n  const stride = 8 * 4;\n  let count = 0;\n  let index = 1;\n\n  layers.forEach((layer) => {\n    layer.strokes.forEach((stroke, strokeIndex) => {\n      const offs = index * stride;\n      data[offs + 0] = PRIMITIVES.indexOf(stroke.primitive); //a.x\n      data[offs + 1] = MODES.indexOf(stroke.mode); //a.y\n      data[offs + 2] = stroke.position[0]; //a.z\n      data[offs + 3] = stroke.position[1]; //a.w\n      data[offs + 4] = stroke.position[2]; //b.x\n      // const rotated = isRotated(stroke.rotation)\n      // data[offs + 5] = rotated ? 1 : 0\n      // if (rotated) {\n      // }\n\n      data[offs + 5] = stroke.rotation[0]; //b.y\n      data[offs + 6] = stroke.rotation[1]; //b.z\n      data[offs + 7] = stroke.rotation[2]; //b.w\n      data[offs + 8] = stroke.size[0]; //c.x\n      data[offs + 9] = stroke.size[1]; //c.y\n      data[offs + 10] = stroke.size[2]; //c.z\n      // 14\n      FIELD_NAMES.forEach((fieldName, fieldIndex) => {\n        data[offs + 11 + fieldIndex] =\n          FIELD_TYPES[fieldIndex] === 'n' ? stroke[fieldName] : stroke[fieldName] ? 1 : 0;\n      });\n      // 11 + 14 = 25 / 4 = 6.25 => 7\n\n      // const mat = invertMatrix(rotationMatrixFromEulers(stroke.rotation));\n      // data[offs + 11]\n      const isLastStroke = strokeIndex === layer.strokes.length - 1;\n      if (isLastStroke) {\n        data[offs + 11 + 15] = 1;\n        data[offs + 11 + 16] = MODES.indexOf(layer.strokes[0].mode);\n        data[offs + 11 + 17] = layer.strokes[0].blend;\n      }\n\n      count += 1;\n      index += 1;\n    });\n  });\n\n  data[0] = count;\n  // console.log({ count, index: index * stride });\n  return data;\n}\n\n///\n\nfunction buildRepo(inputHash, useSeparate = true, coreModels = true) {\n  // console.log('!!! input', inputHash);\n  const normBuilt = buildNorm(buildSelectedLongVersion(inputHash, coreModels), useSeparate);\n  const strokes = normBuilt.map((n) => strokesFromNorm(n));\n  return { repo, strokes };\n}\n\nw.setupRepoModels = setupRepoModels;\nw.buildRepo = buildRepo;\nw.strokesToData = strokesToData;\n\n\n//# sourceURL=webpack://webpack-demo/./src/repo.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/repo.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;