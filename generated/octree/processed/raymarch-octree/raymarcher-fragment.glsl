#version 300 es
precision highp float;precision highp int;uniform float iTime,iDate,iTimeDelta;uniform int iFrame;out lowp vec4 fragColor;
uniform vec2 iResolution;
uniform vec4 iMouse,iLastClick;
in vec2 fragCoord;
uniform sampler2D iTreeTex;uniform sampler2D uResultTex;uniform sampler2D uNormalTex;uniform vec3 uColors[75];uniform vec4 uMaterials[10];uniform vec3 uBoundsMin;uniform vec3 uBoundsMax;uniform vec3 uCameraPos;uniform vec3 uCameraLookAt;uniform float uCameraZoom;uniform vec3 uBackgroundColor1;uniform vec3 uBackgroundColor2;
#define PI 3.1415925359
#define MAX_STEPS 100
#define MAX_DIST 65.
#define SURF_DIST .01
#define ZERO (min(iFrame,0))
#define BOX_OFFS .02
struct Result{float d;float m1;float m2;float b;float k;vec3 normal;float ao;float d2;};float sdBox(vec3 p,vec3 b){vec3 q=abs(p)-b;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);}float aabb_ray_cast(vec3 boxMin,vec3 boxMax,vec3 from,vec3 dir){float tMin;float tMax;vec3 invD=1.0f/dir;vec3 t1=(boxMin.xyz-from)*invD;vec3 t2=(boxMax.xyz-from)*invD;vec3 minComps=min(t1,t2);vec3 maxComps=max(t1,t2);tMin=max(minComps.x,max(minComps.y,minComps.z));tMax=min(maxComps.x,min(maxComps.y,maxComps.z));return max(tMin,tMax);}ivec2 texturePos(int entryIndex,int stride){int width=2048;int perRow=width/stride;int x=int(mod(float(entryIndex),float(perRow)))*stride;int y=entryIndex/perRow;return ivec2(x,y);}Result evalDistanceBounds(vec3 p,out bool hits){vec3 halfSize=(uBoundsMax-uBoundsMin)/2.;vec3 boxPos=uBoundsMin+halfSize;float boxD=sdBox(p-boxPos,halfSize);hits=boxD<SURF_DIST;return Result(boxD+BOX_OFFS,81.,0.,0.,0.,vec3(0),0.,boxD+BOX_OFFS);}Result evalDistance(vec3 p,vec3 dir){vec3 fullSize=uBoundsMax-uBoundsMin;vec3 halfSize=fullSize/2.;vec3 center=uBoundsMin+halfSize;int treeIndex=0;ivec2 texPos;vec4 node;int depth=0;while(true){halfSize=fullSize/float(1<<(depth+1));texPos=texturePos(treeIndex,1);node=texelFetch(iTreeTex,texPos,0);bool recurse=node.x>0.5;if(recurse){ivec3 pos=ivec3(greaterThanEqual(p,center));int octant=(pos.x+(2*pos.y))+(4*pos.z);treeIndex=int(node.x)+octant;center+=((halfSize/2.)*((vec3(pos)*2.)-1.));}else{break;}depth++;if(depth==10)break;}vec4 result=texelFetch(uResultTex,texPos,0);float dist=result.x;if(depth==10){return Result(dist,0.,0.,0.,0.,vec3(0),0.,dist);}else{bool deadEnd=node.x<-0.01;if(deadEnd){vec3 minPos=center-halfSize;vec3 maxPos=center+halfSize;float t=aabb_ray_cast(minPos,maxPos,p,dir);float d=t<0.?dist:min(t+BOX_OFFS,dist);return Result(d,0.,result.z,result.w,0.,vec3(0),0.,dist);}else{vec4 normalAO=texelFetch(uNormalTex,texPos,0);vec3 normal=normalAO.xyz;float ao=normalAO.w;return Result(-.1,result.y,result.z,result.w,0.,normal,ao,dist);}}}void evalMaterial(float m,vec3 p,out vec3 col,out vec4 mat){m-=1.;int colorIndex=int(mod(abs(m),10000.))/10;int materialTypeIndex=int(mod(abs(m),10.));col=uColors[colorIndex]/255.;col=pow(col,vec3(2.2));mat=uMaterials[materialTypeIndex];}void XformP(inout vec3 p){p*=900.;p=(mat3(1,0,0,0,0,1,0,-1,0)*mat3(0,0,1,0,1,0,-1,0,0))*p;p+=vec3(0,0,280);}Result GetDistIgnoreBox(vec3 p,vec3 dir){return evalDistance(p,dir);}Result GetDist(vec3 p,vec3 dir,out bool hits){Result r=evalDistanceBounds(p,hits);if(hits){return evalDistance(p,dir);}else{return r;}}Result RayMarch(vec3 ro,vec3 rd,out int steps){float dO=0.;Result r=Result(dO,0.,0.,0.,0.,vec3(0),0.,dO);int i;for(i=ZERO;i<MAX_STEPS;i++){if(dO>MAX_DIST){break;}vec3 p=ro+(rd*dO);bool hits;Result ds=GetDist(p,rd,hits);if(ds.d<SURF_DIST){dO+=ds.d;r=Result(dO,ds.m1,ds.m2,ds.b,0.,ds.normal,ds.ao,dO);break;}dO+=ds.d;steps=i;}return r;}float shadows(in vec3 ro,in vec3 rd,float mint,float k){float res=1.0;float t=mint;float h=1.0;float maxt=3.;for(;t<maxt;){h=GetDistIgnoreBox(ro+(rd*t),rd).d2;if(h<(SURF_DIST*2.))return 0.;res=min(res,(k*h)/t);t+=h;}return clamp(res,0.0,1.0);}float mapScale(float v,float inMin,float inMax,float outMin,float outMax){return (((v-inMin)*(outMax-outMin))/(inMax-inMin))+outMin;}vec3 GetLight(vec3 pos,vec3 col,vec3 rd,vec4 mat,vec3 nor,float occ){vec3 view=-rd;float angle=1.;vec3 lightPos=vec3(5.*sin(angle),5.,6.+(5.*cos(angle)));vec3 lig=normalize(vec3(0.96,0.8,-0.7));float spow=5.;vec3 ref=reflect(rd,nor);float dif=mapScale(dot(nor,lig),-1.,1.,0.,1.);float amb=clamp(1.5+(0.5*nor.y),0.0,1.0);float spe=pow(clamp(dot(ref,lig),0.0,1.0),spow);float fre=pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);float dom=0.;float shadow=shadows(pos+((nor*SURF_DIST)*2.),lig,0.05,3.);dif*=mapScale(smoothstep(0.,1.,shadow),0.,1.,0.5,1.);vec3 lin=vec3(0.0);lin+=dif;lin+=((amb*0.5)*occ);col=col*lin;return col;}struct ray{vec3 pos;vec3 dir;};ray cameraRay(vec2 uv,vec3 camPos,vec3 lookAt,float zoom){vec3 f=normalize(lookAt-camPos);vec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));vec3 u=normalize(cross(f,r));vec3 c=camPos+(f*zoom);vec3 i=(c+(uv.x*r))+(uv.y*u);vec3 dir=i-camPos;return ray(camPos,normalize(dir));}struct cam{vec3 pos;vec3 lookAt;float zoom;};
#define AA 1
void main(){vec3 tot=vec3(0.0);for(int m=0;m<AA;m++)for(int n=0;n<AA;n++){vec2 o=(vec2(float(m),float(n))/float(AA))-0.5;vec2 uv=fragCoord+(o/iResolution.x);uv.x*=(iResolution.x/iResolution.y);ray camRay=cameraRay(uv,uCameraPos,uCameraLookAt,uCameraZoom);vec3 ro=camRay.pos;vec3 rd=camRay.dir;int steps;Result d=RayMarch(ro,rd,steps);vec3 color=pow(mix(uBackgroundColor1,uBackgroundColor2,uv.y),vec3(2.2));if((d.d<MAX_DIST)&&(d.m1>0.)){vec3 diffuse=vec3(1,1,1);vec4 mat;vec3 pp=ro+(rd*d.d);evalMaterial(d.m1,pp,diffuse,mat);vec3 diffuse2=vec3(1,1,1);vec4 mat2_;evalMaterial(d.m2,pp,diffuse2,mat2_);diffuse=d.m2==0.?diffuse:mix(diffuse,diffuse2,d.b);mat=d.m2==0.?mat:mix(mat,mat2_,d.b);color=GetLight(pp,diffuse,rd,mat,d.normal,d.ao);}tot+=color;}tot/=float(AA*AA);tot=pow(tot,vec3(1./2.2));fragColor=vec4(tot,1.);}